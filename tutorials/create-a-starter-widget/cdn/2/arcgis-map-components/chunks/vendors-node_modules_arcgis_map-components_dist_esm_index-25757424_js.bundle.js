/*! For license information please see vendors-node_modules_arcgis_map-components_dist_esm_index-25757424_js.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-node_modules_arcgis_map-components_dist_esm_index-25757424_js"],{8952:(t,e,o)=>{o.d(e,{A:()=>tt,C:()=>_,a:()=>ot,g:()=>B,m:()=>Z,p:()=>Q,r:()=>J,s:()=>a,t:()=>V,u:()=>S,w:()=>x});var s=o(8740);var n,r=(t,e)=>t.manager.internals.members?.[e]?.[0],i=Symbol.for("controller");function a(t){n!==t&&(n=t,queueMicrotask((()=>{n===t&&(n=void 0)})))}function c(t){return n}var l,h=[];function d(t){if(void 0===t)return void(h=[]);const e=h.indexOf(t);h=-1===e?[...h,t]:h.slice(0,e+1),queueMicrotask((()=>{h=[]}))}var p,u=async(t,e)=>{const o=y(t);if(void 0===o)return t;if(await o.ready,"function"==typeof e){const t=o.watchExports((o=>e(o,t)))}return o.exports},f=async t=>{const e=y(t);return await e.ready,e},y=t=>{const e=function(){const t=l;return l=void 0,t}();if(void 0!==e)return e;const o=c().manager.internals.resolveExports(t);return void 0!==o?o:(t=>"object"==typeof t&&null!==t&&(i in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t)?t:void 0},m={setter:!1,getter:!1,readOnly:!1},g=new WeakMap;p=i;var _=class{constructor(t){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new s.D,this._lifecycleCleanups=[],this.connectedCalled=!1,this._loadCalled=!1,this.loadedCalled=!1,this[p]=!0,this.ready=this._ready.promise,this._exports=k(this),this._exportWatchers=new Set;const e=t??c();this.component=e,this.component.addController(this),d(this);void 0===this.component.manager||queueMicrotask((()=>this.catchUpLifecycle()))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected();!t._loadCalled||this.triggerLoad().then((()=>{!t.loadedCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){const e=this._exports;e!==t&&(this._exports=t,this._exportWatchers.forEach(s.a),this.connectedCalled&&!1!==this.assignedProperty&&this.component.requestUpdate(this.assignedProperty,e)),this._ready.resolve(t)}setProvisionalExports(t){this._exports=k(t),this._exportWatchers.forEach(s.a)}watchExports(t){const e=()=>t(this._exports);return this._exportWatchers.add(e),()=>{this._exportWatchers.delete(e)}}get use(){return a(this.component),u}get useRef(){return a(this.component),f}get useRefSync(){return a(this.component),y}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&(0,s.a)(t.hostConnected,t),this._callbacks.hostConnected.forEach(s.a),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&(0,s.a)(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(s.a),this._lifecycleCleanups.forEach(s.a),this._lifecycleCleanups=[]}async triggerLoad(){if(this._loadCalled)return;this._loadCalled=!0;const t=this;t.hostLoad&&await(0,s.b)(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(s.b)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.loadedCalled)return;const t=this;t.hostLoaded&&(0,s.a)(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(s.a),this.loadedCalled=!0}triggerUpdate(t){const e=this;e.hostUpdate&&(0,s.a)(e.hostUpdate,e,t),this._callbacks.hostUpdate.forEach(b,t)}triggerUpdated(t){const e=this;e.hostUpdated&&(0,s.a)(e.hostUpdated,e,t),this._callbacks.hostUpdated.forEach(b,t)}triggerDestroy(){const t=this;t.hostDestroy&&(0,s.a)(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(s.a)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach(this._callLifecycle,this)}_callLifecycle(t){a(this.component);const e=(0,s.a)(t);(Array.isArray(e)?e:[e]).forEach((t=>{"function"==typeof t?this._lifecycleCleanups.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleCleanups.push(t.remove)}))}};function b(t){(0,s.a)(t,void 0,this)}var v=_;function k(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const e=new Proxy(t,{get(t,o,s){if(!C.has(o)||!(o in t)||t[o]!==e)return o in t||o in Promise.prototype||"symbol"==typeof o?"function"==typeof t?t[o]:Reflect.get(t,o,s):void 0},set:(t,e,o,s)=>Reflect.set(t,e,o,s)});return e}var C=new Set(["exports","_exports"]);var w=void 0;function L(){Array.from(w?.entries()??[]).forEach((([t,{callbacks:e}])=>{const o=Object.keys(t);e.forEach((t=>t(o)))})),w=void 0}function x(t,e,o){var n;const r=e,i=t.manager.internals;(n=i.allWatchers)[r]??(n[r]=[]);const a=i.allWatchers[r],c=o,l=(t,e,o)=>(0,s.a)(c,null,t,e,o);return a.push(l),()=>{const t=a.indexOf(l);-1!==t&&a.splice(t,1)}}var D=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.enableReadonly=()=>{if(this.enableReadonly=void 0,!this.component.manager.isLit)return;const t=this.component.manager.internals;Object.entries(t.members).forEach((([e,[o]])=>{var s;2048&o&&((s=t.setters)[e]??(s[e]=[]),t.setters[e].push(t.readonlySetter))}))},this.trackedValue=U,this.keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this.reactiveUtilsIntegrations=new Set,this._exports=new WeakMap,this.readonlySetter=(t,e,o)=>{if(m.readOnly)return t;throw new Error(`Cannot assign to read-only property "${o}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.component=t}firePropTrackers(t,e){const o=this.keyTrackers;this.trackedValue=U,this.keyTrackers=[],o.forEach((o=>o(t,e)))}getSetProxy(t){const e=this.component,o=e.constructor.prototype;if(this._getSetProxy(o,t,"class"),e.manager.isLit)return;const s=e.el.constructor.prototype;o!==s&&this._getSetProxy(s,t,"html")}_getSetProxy(t,e,o){const s=this.component,n=r(s,e);let i;do{i=Object.getOwnPropertyDescriptor(t,e)}while(!i&&(t=Object.getPrototypeOf(t)));if(!i)return;const a=i.get,c=i.set,l=P in a,h=P in c;if(l&&h)return;const d=!l,p=!h,u=d?function(){let t=a.call(this);const o=g.get(this);if(m.getter||void 0===o)return t;const s=o.manager.internals;t=s.accessorGetter[e](t,e);const n=s.getters[e]??E;for(let o=0;o<n.length;o++)t=n[o](t,e);return t}:a,f=p?function(t){const o=a.call(this),s=g.get(this);if(void 0===s)return void c.call(this,t);let r=s.manager.isLit?t??void 0:function(t,e=8){return null==t||"object"==typeof t||"function"==typeof t?t:4&e?"false"!==t&&(""===t||!!t):2&e?Number.parseFloat(t):1&e?String(t):t}(t,n);const i=s.manager.internals;if(r===o)c.call(this,r);else{const t=m.setter?E:i.setters[e]??E;for(let s=0;s<t.length&&(r=t[s](r,o,e),r!==o);s++);r=i.accessorSetter[e](r,o,e),c.call(this,r),r!==o&&i.enabledWatchers[e]?.forEach((t=>t(r,o,e)))}i.keyTrackers.length>0&&i?.firePropTrackers(e,t)}:c;d&&(u[P]=!0),p&&(f[P]=!0),Object.defineProperty(t,e,{...i,get:u,set:f})}markExports(t,e){("object"==typeof e&&null!==e||"function"==typeof e)&&this._exports.set(e,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},E=[],P=Symbol(),U=Symbol(),S=(t,e)=>new j(t,e),j=class extends v{constructor(t,e){const o="addController"in t,n=new Set;const r=t;if(r.addController=function(e){n.add(e),!(i in e)&&t.renderRoot&&t.el.isConnected&&e.hostConnected?.()},r.removeController=function(t){n.delete(t),t.controllerRemoved?.()},!o){const o=e??t.constructor.__forceUpdate;r.requestUpdate=()=>o(t)}super(t),this.internals=new D(this.component),this.destroyed=!1,this._updatePromise=new s.D,this._originalLifecycles={},this.isLit=o,this.component.manager=this,function(t,e){if(e){const e=t.constructor.elementProperties;t.manager.internals.members=Object.fromEntries(Array.from(e,(([t,e])=>e.noAccessor?void 0:[t,[(e.readOnly?2048:0)|(e.state?32:16)]])).filter(s.i))}else{const e=t.constructor,o=e.__registerControllers?.(t)??void 0;if(e.__registerControllers=void 0,"object"!=typeof o)throw new Error("Failed to retrieve component meta");t.manager.internals.members=Object.fromEntries(Object.entries(o).filter((([t,[e]])=>!!(63&e))))}}(t,o),this._controllers=n,this.exports=void 0,this.hasDestroy=O in this.component&&"function"==typeof this.component.destroy,this._bindLifecycleMethods();const c=this.internals;Object.keys(c.members).forEach((t=>{c.accessorGetter[t]=T,c.accessorSetter[t]=T,c.getSetProxy(t)})),o?this.internals.enabledWatchers=this.internals.allWatchers:Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise}),queueMicrotask(c.enableReadonly),d(void 0),a(t),g.set(t.el,t),g.set(t,t)}_bindLifecycleMethods(){const t=this.component,e=this.isLit,o=t.el===t;this._originalLifecycles={_connectedCallback:e||o?void 0:t.connectedCallback,_disconnectedCallback:e||o?void 0:t.disconnectedCallback,_load:e?t.load:t.componentWillLoad,_loaded:e?t.loaded:t.componentDidLoad,_willUpdate:e?void 0:t.componentWillUpdate,_updated:e?void 0:t.componentDidUpdate,_destroy:t.destroy};const s=this._connectedCallback.bind(this),n=this._disconnectedCallback.bind(this),r=this._update.bind(this),i=this._updated.bind(this);e?t.constructor.prototype.addController.call(t,{hostConnected:s,hostDisconnected:n,hostUpdate:r,hostUpdated:i}):(t.connectedCallback=s,t.disconnectedCallback=n,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=r,t.componentDidUpdate=i),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${O} prop.`)}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout);const t=this.internals;t.enabledWatchers=t.allWatchers,L(),t.enableReadonly?.(),this._controllers.forEach(W),this._originalLifecycles._connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach(R),this._originalLifecycles._disconnectedCallback?.call(this.component),this.hasDestroy&&this._setAutoDestroyTimeout())}async _load(){const t=this.internals.reactiveUtilsIntegrations;if(t.size>0)for(const e of t)"triggerLoad"in e?await e.triggerLoad():await(0,s.b)(e.hostLoad,e);await Promise.allSettled(Array.from(this._controllers,M,t)),await(this._originalLifecycles._load?.call(this.component)),this.hasDestroy&&x(this.component,O,(()=>this._setAutoDestroyTimeout()))}_loaded(){this._controllers.forEach(q),this._originalLifecycles._loaded?.call(this.component)}_update(){const t=this.component.changedProperties;this._controllers.forEach(G,t),this._originalLifecycles._willUpdate?.call(this.component)}_updated(){const t=this.component;if(this._controllers.forEach(N,t.changedProperties),this._originalLifecycles._updated?.call(this.component),this.isLit)t.changedProperties=new Map;else{const t=this._updatePromise;this._updatePromise=new s.D,t.resolve(!0)}}async destroy(){if(!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach(I),this._controllers.clear(),await(this._originalLifecycles._destroy?.call(this.component))}}_setAutoDestroyTimeout(){if(void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),!this.component.el.isConnected&&!this.component.autoDestroyDisabled){const t=()=>{this.destroy().catch(console.error)};this._autoDestroyTimeout=(0,s.d)(t,A)}}},O="autoDestroyDisabled",A=1e3,T=t=>t;function W(t){"triggerConnected"in t?t.triggerConnected():(0,s.a)(t.hostConnected,t)}function R(t){"triggerDisconnected"in t?t.triggerDisconnected():(0,s.a)(t.hostDisconnected,t)}async function M(t){this.has(t)||("triggerLoad"in t?await t.triggerLoad():await(0,s.b)(t.hostLoad,t))}function q(t){"triggerLoaded"in t?t.triggerLoaded():(0,s.a)(t.hostLoaded,t)}function G(t){"triggerUpdate"in t?t.triggerUpdate(this):(0,s.a)(t.hostUpdate,t,this)}function N(t){"triggerUpdated"in t?t.triggerUpdated(this):(0,s.a)(t.hostUpdated,t,this)}function I(t){"triggerDestroy"in t?t.triggerDestroy():(0,s.a)(t.hostDestroy,t)}function V(t,e,o){const n=t.manager.internals;return n.trackedValue!==U&&n.trackedValue!==o&&n.firePropTrackers(void 0,void 0),0===n.keyTrackers.length&&queueMicrotask((()=>n.firePropTrackers(void 0,void 0))),n.trackedValue=o,n.keyTrackers.push(((t,n)=>(0,s.a)(e,void 0,o===n?t:void 0))),o}function $(t,e,o){const n=Array.isArray(t)?t:[t];let i=n.length+1;const a=t=>{i-=1,void 0!==t&&(i=0),0===i&&e(t)};n.forEach((t=>function(t,e,o){const n=Object.keys(t),r=n.length;void 0===w&&queueMicrotask(L),w??(w=new Map);let i=w.get(t);return void 0===i&&(i={callbacks:[],keyCount:r},w.set(t,i)),i.keyCount!==r&&(i.callbacks.forEach((t=>t(n))),i.callbacks=[],i.keyCount=r),i.callbacks.push((n=>{const i=t=>(0,s.a)(e,null,t),a=n[r];void 0===a?i(void 0):t[a]===o?i(a):i(void 0)})),o}(t,(e=>a(void 0===e?void 0:{key:e,host:t,isReactive:!1})),o)));const c=n.find((t=>"manager"in t&&"object"==typeof t.manager&&t.manager.component===t));return c&&V(c,(t=>a(void 0===t?void 0:{key:t,host:c,isReactive:void 0!==r(c,t)})),o),o}function B(t,e){const o=c();return V(o,(s=>{const n=s,r=o.manager,i=o,a=i[n];if(null!=a&&a!==t&&"function"==typeof e.set){const o=e.set(a,t,n);if(o!==a)if(r.isLit)i[n]=o;else{let t=!0;r.onConnected((()=>{t&&(t=!0,F((()=>{i[n]=o})))}))}}!function(t,e,o){var s,n;const r=o,i=t.manager.internals,a="function"==typeof r.get?r.get:void 0;a&&((s=i.getters)[e]??(s[e]=[]),i.getters[e].unshift(a));const c="ignore"===r.set?H:r.set;c&&((n=i.setters)[e]??(n[e]=[]),i.setters[e].unshift(c))}(o,n,e)}),t)}function F(t){m.setter=!0;try{return t()}finally{m.setter=!1}}function z(t){m.getter=!0;try{return t()}finally{m.getter=!1}}var H=(t,e)=>e;function J(t){return B(t,{set:c().manager.internals.readonlySetter})}var K,Q=t=>(...e)=>{const o=h,s=new t(...e),n=s.exports;d(o.at(-1));const r=s.component.manager.internals;var i;r.markExports(s,n),s.watchExports((t=>r.markExports(s,t))),l!==(i=s)&&(l=i,queueMicrotask((()=>{l===i&&(l=void 0)})));return $([s.component,...o].reverse(),(t=>void 0===t?void 0:function(t,{host:e,key:o,isReactive:s},n){const r=e,i=r[o]!==t.exports,a=r[o]!==n,c=n!==t.exports;i&&!a&&c&&(r[o]=t.exports);const l=e===t.component;if(l){if(s){const e=t.component.manager.internals;a&&e.markExports(t,r[o]),x(t.component,o,(o=>{o!==t.exports&&e.markExports(t,o)}))}t.assignedProperty=s?void 0:o}t.watchExports((()=>{if(r[o]===t.exports)return;const e=t.component.manager,s=e.internals.setters[o]?.includes(e.internals.readonlySetter);s?function(t){m.readOnly=!0;try{return t()}finally{m.readOnly=!1}}((()=>{r[o]=t.exports})):r[o]=t.exports}))}(s,t,n)),n)};var X=Promise.all([(0,s.c)(),(0,s.e)()]),Y=class extends _{async hostLoad(){const[t,{subclass:e,property:o}]=await X;class s extends t{}const n=(t,e)=>l[e];function r(t,e,o){return void 0!==l&&(l[o]=t),t}const i=this.component,a=i.manager.internals,c=[];if(z((()=>Object.keys(a.members).forEach((t=>{a.accessorSetter[t]!==T||(c.push(t),a.accessorGetter[t]=n,a.accessorSetter[t]=r,o({value:i[t]})(s.prototype,t))})))),this._enabledMembers=c,0===c.length)return;const l=new(e(i.el.tagName)(s));this._instance=l}controllerRemoved(){super.controllerRemoved();const t=this.component.manager.internals;this._instance?.destroy(),this._enabledMembers?.forEach((e=>{t.accessorGetter[e]=T,t.accessorSetter[e]=T}))}},Z=(t,e)=>(e,o)=>et(e,t,o),tt=class extends v{constructor(t,e,o){super(t),this._loadAccessor=e,this._options=o,this._watchedProperties=new Map,this._isBinding={value:!0},this.setProvisionalExports(ot.makeGetterProxy(t,this._watchedProperties,this._isBinding,this.constructor.allowedPropNameMismatches));const s=t.manager.internals.reactiveUtilsIntegrations;s.add(this);const n=Array.from(s).find((t=>t instanceof Y));n&&s.delete(n),s.add(n??new Y(this.component)),V(t,(t=>{t&&(this._instancePropName=t)}),this.exports)}hostConnected(){this._isBinding.value=!1}async hostLoad(){this.reactiveUtils=await async function(){return K??(K=(0,s.h)()),await K}();const t=this.component,e=this._gatherParameters(),o=this._options?.editConstructorProperties?.call(t,e)??e,n=o instanceof Promise?await o:o,r=t,i="string"==typeof this._instancePropName?r[this._instancePropName]:void 0;null!=i&&i!==this.exports?(this._instance=i,i.set(n)):this._instance=await this._createInstance(n),t.manager.destroyed||(ot.watchComponentUpdates(this,this._instance,this._watchedProperties),ot.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance)}_gatherParameters(){return Object.fromEntries(Array.from(this._watchedProperties,(([t,e])=>[e,this.component[t]])).filter((([,t])=>void 0!==t)))}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}hostDestroy(){this._instance&&this._instance.destroy()}async reCreate(){this.hostDestroy(),await this.hostLoad()}},et=Q(tt),ot={makeGetterProxy:(t,e,o,s)=>new Proxy({},{has:(t,e)=>"string"==typeof e||e in t,get:(s,n)=>{const r=Reflect.get(s,n);if("symbol"==typeof n||n in Promise.prototype)return r;return n in s||!(o?.value??!0)?r:$(t,(t=>{void 0!==t&&e.set(t.key,n)}),r)}}),watchComponentUpdates(t,e,o){function s(t,s){const n=o.get(s),r=e[n];return"boolean"==typeof r&&n!==s&&s.toLowerCase().includes("disable")?!r:r}const n=(t,s,n)=>{const r=o.get(n),i=e[r],a="boolean"==typeof i&&r!==n&&n.toLowerCase().includes("disable");if((a?!i:i)===t)return t;e[r]=a?!t:t;const c=e[r];return a?!c:c},r=t.component.manager.internals;o.forEach(((t,e)=>{r.accessorGetter[e]=s,r.accessorSetter[e]=n}))},watchAccessorUpdates(t,e,o){const{component:s}=t,n=s,r=e,i=function(t){const e=t,o=Object.entries(e.__accessor__?.metadata??{});return new Set(o.filter((([t,e])=>!0===e?.readOnly)).map((([t])=>t)))}(e);z((()=>o.forEach(((t,e)=>{if(i.has(t))return;const o=n[e],s=r[t],a="boolean"==typeof o&&t!==e&&e.toLowerCase().includes("disable")?!o:o;null!=a&&s!==a&&(r[t]=a)})))),t.onLifecycle((()=>{if(!e.destroyed)return Array.from(o,(([e,o])=>t.reactiveUtils.watch((()=>r[o]),(()=>{const t=r[o],s="boolean"==typeof t&&o!==e&&e.toLowerCase().includes("disable")?!t:t;F((()=>{n[e]=s}))}),{initial:!0})))}))},reEmitAccessorEvents(t,e,o,n){if(!("on"in e&&"function"==typeof e.on))return;const r=Object.entries(t.component).map((([t,e])=>{const o=e;if(!t.startsWith(n)||t===n||"object"!=typeof o||null===o||!("emit"in o)||"function"!=typeof o.emit)return;const r=o.emit,i=t.slice(n.length);return[(0,s.f)(i).toLowerCase(),r]})).filter(s.i);if(0===r.length)return;const i=e,a=()=>i;t.onLifecycle((()=>{if(!e.destroyed)return r.map((([t,e])=>o.on(a,t,e)))}))},async reCreate(t,e){const o=e.manager.useRefSync(t);void 0!==o&&await o.reCreate()}}}}]);
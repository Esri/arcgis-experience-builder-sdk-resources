/*! For license information please see 729.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([[729],{729:(t,e,n)=>{n.r(e),n.d(e,{groupTimeZones:()=>T});const o=(()=>{const t=Intl.supportedValuesOf("timeZone");return[...new Set([...t,"Etc/GMT+1","Etc/GMT+10","Etc/GMT+11","Etc/GMT+12","Etc/GMT+2","Etc/GMT+3","Etc/GMT+4","Etc/GMT+5","Etc/GMT+6","Etc/GMT+7","Etc/GMT+8","Etc/GMT+9","Etc/GMT-1","Etc/GMT-10","Etc/GMT-11","Etc/GMT-12","Etc/GMT-13","Etc/GMT-14","Etc/GMT-2","Etc/GMT-3","Etc/GMT-4","Etc/GMT-5","Etc/GMT-6","Etc/GMT-7","Etc/GMT-8","Etc/GMT-9"])]})(),r={startDate:(new Date).toISOString(),groupDateRange:365,debug:!1},a=new Set(["Europe","Asia","America","America/Argentina","Africa","Australia","Pacific","Atlantic","Antarctica","Arctic","Indian"]),i=t=>{if(t.includes("Istanbul"))return"Europe";const e=t.lastIndexOf("/");return-1===e?t:t.slice(0,e)},s=t=>a.has(t),c=(t,e,n,o,r=!1)=>{const a=new Map;r&&console.log(`Initializing data starting ${e} with ${n} days in the future, comparing ${t.length} timezones`);const c=((t,e,n)=>{const o=[];let r=n.create(t);for(let t=0;t<=e;t++)r=n.increase(r),o.push(n.formatToIsoDateString(r));return o})(e,n,o);return t.map((t=>{const e=t.label,n=i(e),r=c.map((t=>{const n=`${t}-${e}`;let r=a.get(n);return r||(r=o.isoToTimeZone(t,e),a.set(n,r),r)}));return{...t,continent:n,isRegularContinent:s(n),dates:r}}))},l=(t,e,n)=>t.length===e.length&&t.every(((t,o)=>n.same(t,e[o]))),u=(t,e=5)=>{const n=t.filter((({label:t})=>s(i(t))));return 0===n.length?[0]:function(t,e=5){const n=t.length;if(n<=e)return t;const o=Math.min(n-2,e-2),r=(n-1)/(o+1);return[t[0],...Array.from({length:o},((e,n)=>t[Math.round((n+1)*r)])),t[n-1]]}(n.map((e=>t.indexOf(e))),e)};async function T(t){const{debug:e,groupDateRange:n,hooks:a,startDate:i,dateEngine:s}={...r,...t},T=[];if(!s)throw new Error("dateEngine is required");const g=o.map((t=>({label:t})));a?.onBeforeTimeZoneMetadataCreate?.(g);const G=c(g,i,n,s,e);a?.onTimeZoneMetadataCreate?.(G);for(const t of G){const{label:e,continent:n,dates:o}=t;if(t.visited)continue;t.visited=!0;const r={labelTzIndices:void 0,tzs:[{label:e}]};a?.onGroupCreate?.(r,t);for(const t of G.filter((t=>!t.visited))){const{label:e,continent:i,isRegularContinent:c,dates:u}=t;if((n===i||!c)&&l(o,u,s)){const n={label:e};r.tzs.push(n),a?.onGroupTimeZoneAdd?.(r,n,t),t.visited=!0}}T.push(r),a?.onGroupAdd?.(r)}const E=T.map((t=>{a?.onBeforeFinalGroupCreate?.(t),t.tzs=t.tzs.sort(((t,e)=>t.label.localeCompare(e.label)));const e={labelTzIndices:u(t.tzs,7),tzs:t.tzs.map((t=>t.label))};return a?.onFinalGroupCreate?.(e,t),e})).sort(((t,e)=>e.tzs.length-t.tzs.length));if(e){const t=o.map((t=>E.some((e=>e.tzs.includes(t)))?null:t)).filter(Boolean);if(t.length>0)throw new Error(`There are ${t.length} missing timezones: ${t.toString()}`)}return a?.onFinalGroupingCreate?a.onFinalGroupingCreate(E):E}}}]);
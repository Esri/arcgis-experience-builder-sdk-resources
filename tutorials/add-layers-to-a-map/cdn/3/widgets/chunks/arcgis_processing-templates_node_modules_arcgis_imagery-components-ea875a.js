/*! For license information please see arcgis_processing-templates_node_modules_arcgis_imagery-components-ea875a.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-extensions_widgets_arcgis_processing-templates_node_modules_arcgis_imagery-components-ea875a"],{14886:(t,e,o)=>{o.d(e,{d:()=>C,g:()=>i,l:()=>ut,m:()=>pt,u:()=>X});var s=class{resolve(t){}reject(t){}constructor(){this.promise=new Promise(((t,e)=>{this.resolve=t,this.reject=e}))}};function n(t,e,o){const{subscribe:s}=function(t){const e=t.join(","),o=r[e];if(void 0!==o)return o;const s=new Set,n=new MutationObserver((t=>s.forEach((e=>e(t)))));globalThis.document&&n.observe(document.documentElement,{attributes:!0,attributeFilter:t,subtree:!0});const i={subscribe:t=>(s.add(t),()=>{s.delete(t),0===s.size&&(n.disconnect(),r[e]=void 0)})};return r[e]=i,i}(e);return s((e=>{const s=e.some((e=>function(t,e){let o=t;for(;o;){if(o===e)return!0;if(!o.parentNode)return!1;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode}return!1}(t,e.target)));s&&o()}))}var r={};function i(t){return c(t,"dir","ltr")}function c(t,e,o){const s=function(t,e){let o=t;for(;o;){const t=o.closest?.(e);if(t)return t;const s=o.getRootNode?.();if(s===globalThis.document)return null;o=s.host}return null}(t,`[${e}]`);return s?.getAttribute(e)??o}function a(t,e,...o){try{return t?.call(e,...o)}catch(e){console.error(e,t)}}async function l(t,e,...o){try{const s=t?.call(e,...o);return s instanceof Promise?await s:s}catch(e){console.error(e,t)}}var h=new Set(["ar","bg","bs","ca","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","id","it","ja","ko","lt","lv","nl","nb","no","pl","pt-BR","pt-PT","ro","ru","sk","sl","sr","sv","th","tr","uk","vi","zh-CN","zh-HK","zh-TW"]),d="en",u={pt:"pt-PT",nb:"no",zh:"zh-CN"};async function p(t,e,o=""){const s=`${e}/${o}`,n=`${s}${t}.json`;return f[n]??(f[n]=y(t,s)),await f[n]}var f={};async function y(t,e){const o=`${e}${t}.json`;try{const t=await fetch(o);if(t.ok)return await t.json()}catch(t){return console.error(t),{}}return t===d?{}:await y(d,e)}function g(t){const e=c(t,"lang",globalThis.navigator?.language||d);return{lang:e,t9nLocale:m(e)}}function m(t){const[e,o]=t.split("-"),s=e.toLowerCase();let n=s;return o&&(n=`${s}-${o.toUpperCase()}`),n=u[n]??n,h.has(n)?n:o?m(s):d}function _(t,e,o,s){let r;const i=()=>{(async function(t,e,o=t.tagName.toLowerCase().split("-").slice(1).join("-")){const{lang:s,t9nLocale:n}=g(t),r=`${e}/${o}/t9n`,i="messages.",c=null===o?{}:await p(n,r,i);return{lang:s,t9nLocale:n,t9nStrings:c}})(t,e(),s).then((t=>{r?.lang===t.lang&&r.t9nLocale===t.t9nLocale&&r.t9nStrings===t.t9nStrings||o(t),r=t})).catch(console.error)};return queueMicrotask(i),n(t,["lang"],i)}var b=4e3,v=2e3,k=4;function L(t){return void 0!==t}function C(t,e=100){let o;return(...s)=>{clearTimeout(o),o=setTimeout((()=>{clearTimeout(o),t(...s)}),e)}}var x,w=Symbol.for("controller");function D(t){x!==t&&(x=t,queueMicrotask((()=>{x===t&&(x=void 0)})))}function E(t){return x}var U,P=[];function T(t){if(void 0===t)return void(P=[]);const e=P.indexOf(t);P=-1===e?[...P,t]:P.slice(0,e+1),queueMicrotask((()=>{P=[]}))}function j(){return P}var S,O=async(t,e)=>{const o=$(t);if(void 0===o)return t;if(await o.ready,"function"==typeof e){const t=o.watchExports((o=>e(o,t)))}return o.exports},W=async t=>{const e=$(t);return await e.ready,e},$=t=>{const e=E().manager.internals.resolveExports(t);if(void 0!==e)return e;if((t=>"object"==typeof t&&null!==t&&(w in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t))return t;const o=function(){const t=U;return U=void 0,t}();return void 0!==o?o:void 0},M={setter:!1,getter:!1,readOnly:!1},R=new WeakMap;S=w;var A=class{constructor(t){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new s,this._lifecycleCleanups=[],this.connectedCalled=!1,this._loadCalled=!1,this.loadedCalled=!1,this[S]=!0,this.ready=this._ready.promise,this._exports=z(this),this._exportWatchers=new Set;const e=t??E();this.component=e,this.component.addController(this);void 0===this.component.manager||(T(this),queueMicrotask((()=>this.catchUpLifecycle())))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected();!t._loadCalled||this.triggerLoad().then((()=>{!t.loadedCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){const e=this._exports;e!==t&&(this._exports=t,this._exportWatchers.forEach(a),this.connectedCalled&&!1!==this.assignedProperty&&this.component.requestUpdate(this.assignedProperty,e)),this._ready.resolve(t)}setProvisionalExports(t,e=!0){this._exports=e?z(t):t,this._exportWatchers.forEach(a)}watchExports(t){const e=()=>t(this._exports);return this._exportWatchers.add(e),()=>{this._exportWatchers.delete(e)}}get use(){return D(this.component),O}get useRef(){return D(this.component),W}get useRefSync(){return D(this.component),$}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&a(t.hostConnected,t),this._callbacks.hostConnected.forEach(a),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&a(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(a),this._lifecycleCleanups.forEach(a),this._lifecycleCleanups=[]}async triggerLoad(){if(this._loadCalled)return;this._loadCalled=!0;const t=this;t.hostLoad&&await l(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(l)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.loadedCalled)return;const t=this;t.hostLoaded&&a(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(a),this.loadedCalled=!0}triggerUpdate(t){const e=this;e.hostUpdate&&a(e.hostUpdate,e,t),this._callbacks.hostUpdate.forEach(q,t)}triggerUpdated(t){const e=this;e.hostUpdated&&a(e.hostUpdated,e,t),this._callbacks.hostUpdated.forEach(q,t)}triggerDestroy(){const t=this;t.hostDestroy&&a(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(a)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach(this._callLifecycle,this)}_callLifecycle(t){D(this.component);const e=a(t);(Array.isArray(e)?e:[e]).forEach((t=>{"function"==typeof t?this._lifecycleCleanups.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleCleanups.push(t.remove)}))}};function q(t){a(t,void 0,this)}var N=A;function z(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const e=new Proxy(t,{get(t,o,s){if(!V.has(o)||!(o in t)||t[o]!==e)return o in t||o in Promise.prototype||"symbol"==typeof o?"function"==typeof t?t[o]:Reflect.get(t,o,s):void 0},set:(t,e,o,s)=>Reflect.set(t,e,o,s)});return e}var V=new Set(["exports","_exports"]);var I=void 0;function F(){Array.from(I?.entries()??[]).forEach((([t,{callbacks:e}])=>{const o=Object.keys(t);e.forEach((t=>t(o)))})),I=void 0}function G(t,e,o){var s;const n=e,r=t.manager.internals;(s=r.allWatchers)[n]??(s[n]=[]);const i=r.allWatchers[n],c=o,l=(t,e,o)=>a(c,null,t,e,o);return i.push(l),()=>{const t=i.indexOf(l);-1!==t&&i.splice(t,1)}}var B=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.enableReadonly=()=>{if(this.enableReadonly=void 0,!this.component.manager.isLit)return;const t=this.component.manager.internals;Object.entries(t.members).forEach((([e,[o]])=>{var s;2048&o&&((s=t.setters)[e]??(s[e]=[]),t.setters[e].push(t.readonlySetter))}))},this.trackedValue=J,this.keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this._exports=new WeakMap,this.readonlySetter=(t,e,o)=>{if(M.readOnly)return t;throw new Error(`Cannot assign to read-only property "${o}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.component=t}firePropTrackers(t,e){const o=this.keyTrackers;this.trackedValue=J,this.keyTrackers=[],o.forEach((o=>o(t,e)))}getSetProxy(t){const e=this.component,o=e.constructor.prototype;if(this._getSetProxy(o,t,"class"),e.manager.isLit)return;const s=e.el.constructor.prototype;o!==s&&this._getSetProxy(s,t,"html")}_getSetProxy(t,e,o){const s=((t,e)=>t.manager.internals.members?.[e]?.[0])(this.component,e);let n;do{n=Object.getOwnPropertyDescriptor(t,e)}while(!n&&(t=Object.getPrototypeOf(t)));if(!n)return;const r=n.get,i=n.set,c=K in r,a=K in i;if(c&&a)return;const l=!c,h=!a,d=l?function(){let t=r.call(this);const o=R.get(this);if(void 0===o)return t;const s=o.manager.internals;t=s.accessorGetter[e](t,e);const n=s.getters[e]??H;for(let o=0;o<n.length;o++)t=n[o](t,e);return t}:r,u=h?function(t){const o=r.call(this),n=R.get(this);if(void 0===n)return void i.call(this,t);let c=n.manager.isLit?t??void 0:function(t,e=8){return null==t||"object"==typeof t||"function"==typeof t?t:4&e?"false"!==t&&(""===t||!!t):2&e?Number.parseFloat(t):1&e?String(t):t}(t,s);const a=n.manager.internals;if(c===o)i.call(this,c);else{const t=a.setters[e]??H;for(let s=0;s<t.length&&(c=t[s](c,o,e),c!==o);s++);c=a.accessorSetter[e](c,o,e),i.call(this,c),c!==o&&a.enabledWatchers[e]?.forEach((t=>t(c,o,e)))}a.keyTrackers.length>0&&a?.firePropTrackers(e,t)}:i;l&&(d[K]=!0),h&&(u[K]=!0),Object.defineProperty(t,e,{...n,get:d,set:u})}markExports(t,e){("object"==typeof e&&null!==e||"function"==typeof e)&&this._exports.set(e,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},H=[],K=Symbol(),J=Symbol();function Q(t=[E(),...j()],e,o){const s=Array.isArray(t)?t:[t];let n=s.length+1;const r=t=>{n-=1,void 0!==t&&(n=Math.min(n,0)),0===n&&e(t)};s.forEach((t=>function(t,e,o){const s=Object.keys(t),n=s.length;void 0===I&&queueMicrotask(F),I??(I=new Map);let r=I.get(t);return void 0===r&&(r={callbacks:[],keyCount:n},I.set(t,r)),r.keyCount!==n&&(r.callbacks.forEach((t=>t(s))),r.callbacks=[],r.keyCount=n),r.callbacks.push((s=>{const r=t=>a(e,null,t),i=s[n];void 0===i?r(void 0):t[i]===o?r(i):r(void 0)})),o}(t,(e=>r(void 0===e?void 0:{key:e,host:t,isReactive:!1})),o)));const i=s.find((t=>"manager"in t&&"object"==typeof t.manager&&t.manager.component===t));return i&&function(t,e,o){const s=t.manager.internals;s.trackedValue!==J&&s.trackedValue!==o&&s.firePropTrackers(void 0,void 0),0===s.keyTrackers.length&&queueMicrotask((()=>s.firePropTrackers(void 0,void 0))),s.trackedValue=o,s.keyTrackers.push(((t,s)=>a(e,void 0,o===s?t:void 0)))}(i,(t=>r(void 0===t?void 0:{key:t,host:i,isReactive:!0})),o),o}var X=(t,e)=>new Y(t,e),Y=class extends N{constructor(t,e){const o="addController"in t,n=new Set;const r=t;if(r.addController=function(e){n.add(e),!(w in e)&&t.renderRoot&&t.el.isConnected&&e.hostConnected?.()},r.removeController=function(t){n.delete(t),t.controllerRemoved?.()},!o){const o=e??t.constructor.__forceUpdate;r.requestUpdate=()=>o(t)}super(t),this.internals=new B(this.component),this.destroyed=!1,this._updatePromise=new s,this._originalLifecycles={},this.isLit=o,this.component.manager=this,function(t,e){if(e){const e=t.constructor.elementProperties;t.manager.internals.members=Object.fromEntries(Array.from(e,(([t,e])=>e.noAccessor?void 0:[t,[(e.readOnly?2048:0)|(e.state?32:16)]])).filter(L))}else{const e=t.constructor,o=e.__registerControllers?.(t)??void 0;if(e.__registerControllers=void 0,"object"!=typeof o)throw new Error("Failed to retrieve component meta");t.manager.internals.members=Object.fromEntries(Object.entries(o).filter((([t,[e]])=>!!(63&e))))}}(t,o),this._controllers=n,this.exports=void 0,this.hasDestroy=Z in this.component&&"function"==typeof this.component.destroy,this._bindLifecycleMethods();const i=this.internals;Object.keys(i.members).forEach((t=>{i.accessorGetter[t]=et,i.accessorSetter[t]=et,i.getSetProxy(t)})),o?this.internals.enabledWatchers=this.internals.allWatchers:Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise}),queueMicrotask(i.enableReadonly),D(t),R.set(t.el,t),R.set(t,t)}_bindLifecycleMethods(){const t=this.component,e=this.isLit,o=t.el===t;this._originalLifecycles={_connectedCallback:e||o?void 0:t.connectedCallback,_disconnectedCallback:e||o?void 0:t.disconnectedCallback,_load:e?t.load:t.componentWillLoad,_loaded:e?t.loaded:t.componentDidLoad,_willUpdate:e?void 0:t.componentWillUpdate,_updated:e?void 0:t.componentDidUpdate,_destroy:t.destroy};const s=this._connectedCallback.bind(this),n=this._disconnectedCallback.bind(this),r=this._update.bind(this),i=this._updated.bind(this);e?t.constructor.prototype.addController.call(t,{hostConnected:s,hostDisconnected:n,hostUpdate:r,hostUpdated:i}):(t.connectedCallback=s,t.disconnectedCallback=n,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=r,t.componentDidUpdate=i),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It cannot be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${Z} prop.`)}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout);const t=this.internals;t.enabledWatchers=t.allWatchers,F(),t.enableReadonly?.(),this._controllers.forEach(ot),this._originalLifecycles._connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach(st),this._originalLifecycles._disconnectedCallback?.call(this.component),this.hasDestroy&&this._setAutoDestroyTimeout())}async _load(){await Promise.allSettled(Array.from(this._controllers,nt)),await(this._originalLifecycles._load?.call(this.component)),this.hasDestroy&&G(this.component,Z,(()=>this._setAutoDestroyTimeout()))}_loaded(){this._controllers.forEach(rt),this._originalLifecycles._loaded?.call(this.component)}_update(){const t=this.component;return this._controllers.forEach(it,t.$changes),this._originalLifecycles._willUpdate?.call(this.component)}_updated(){const t=this.component;if(this._controllers.forEach(ct,t.$changes),this._originalLifecycles._updated?.call(this.component),this.isLit)t.$changes=new Map;else{const t=this._updatePromise;this._updatePromise=new s,t.resolve(!0)}}async destroy(){if(!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach(at),this._controllers.clear(),await(this._originalLifecycles._destroy?.call(this.component))}}_setAutoDestroyTimeout(){if(void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),!this.component.el.isConnected&&!this.component.autoDestroyDisabled){const t=()=>{this.destroy().catch(console.error)};this._autoDestroyTimeout=function(t,e){const o=e>b?v:e/k;let s=0;const n=setInterval((()=>{s+=o,s>=e&&(clearInterval(n),t())}),o);return n}(t,tt)}}},Z="autoDestroyDisabled",tt=1e3,et=t=>t;function ot(t){"triggerConnected"in t?t.triggerConnected():a(t.hostConnected,t)}function st(t){"triggerDisconnected"in t?t.triggerDisconnected():a(t.hostDisconnected,t)}async function nt(t){"triggerLoad"in t?await t.triggerLoad():await l(t.hostLoad,t)}function rt(t){"triggerLoaded"in t?t.triggerLoaded():a(t.hostLoaded,t)}function it(t){"triggerUpdate"in t?t.triggerUpdate(this):a(t.hostUpdate,t,this)}function ct(t){"triggerUpdated"in t?t.triggerUpdated(this):a(t.hostUpdated,t,this)}function at(t){"triggerDestroy"in t?t.triggerDestroy():a(t.hostDestroy,t)}var lt,ht=t=>dt(void 0,t),dt=(lt=class extends A{constructor(t,e){super(t);const o=this.exports;try{D(this.component);const t=e(this.component,this),s=this.exports!==o;if(t instanceof Promise){s||this.setProvisionalExports(t);const e=t.then((t=>{this.exports=t,super.catchUpLifecycle()})).catch((t=>{this._ready.reject(t),console.error(t)}));this.onLoad((async()=>await e))}else s&&void 0===t||(this.exports=t),queueMicrotask((()=>super.catchUpLifecycle()))}catch(t){this._ready.reject(t),console.error(t)}}catchUpLifecycle(){}},(...t)=>{const e=j(),o=new lt(...t),s=o.exports;T(e.at(-1));const n=o.component.manager.internals;var r;return n.markExports(o,s),o.watchExports((t=>n.markExports(o,t))),U!==(r=o)&&(U=r,queueMicrotask((()=>{U===r&&(U=void 0)}))),Q([o.component,...e].reverse(),(t=>void 0===t?void 0:function(t,{host:e,key:o,isReactive:s},n){const r=e,i=r[o]!==t.exports,c=r[o]!==n,a=n!==t.exports;i&&!c&&a&&(r[o]=t.exports);const l=e===t.component;if(l){if(s){const e=t.component.manager.internals;c&&e.markExports(t,r[o]),G(t.component,o,(o=>{o!==t.exports&&e.markExports(t,o)}))}t.assignedProperty=s?void 0:o}t.watchExports((()=>{if(r[o]===t.exports)return;const e=t.component.manager,s=e.internals.setters[o]?.includes(e.internals.readonlySetter);s?function(t){M.readOnly=!0;try{return t()}finally{M.readOnly=!1}}((()=>{r[o]=t.exports})):r[o]=t.exports}))}(o,t,s)),s)}),ut=ht,pt=t=>(e={})=>ht(((o,s)=>{const n=g(o.el),r={_lang:n.lang,_t9nLocale:n.t9nLocale,_loading:!0},i=o;function c(t){const e=s.exports,o=e._original??e,n=ft(o,t);t&&(n._original=o),s.exports=n}return s.onLifecycle((()=>_(o.el,(()=>t("./assets")),(({t9nLocale:t,t9nStrings:e,lang:n})=>{const r={...e,_lang:n,_t9nLocale:t,_loading:!1};s.exports=r;const a=e.componentLabel;"string"==typeof a&&"label"in o&&null==o.label&&(o.label??(o.label=a)),c(i.messageOverrides)}),e.name))),"messageOverrides"in i&&s.onLifecycle((()=>G(i,"messageOverrides",c))),e.blocking?(s.setProvisionalExports(r,!1),s.ready):r}));function ft(t,e){if(!e)return t;const o={...t};return Object.entries(e).forEach((([e,s])=>{o[e]="object"==typeof s?ft(t[e],s):s??t[e]})),o}}}]);